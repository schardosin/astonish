"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7099],{2442:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"tutorials/advanced-flows","title":"Advanced Flows","description":"This tutorial covers advanced techniques for creating complex agentic flows in Astonish, including loops, conditional branching, error handling, and more.","source":"@site/docs/tutorials/advanced-flows.md","sourceDirName":"tutorials","slug":"/tutorials/advanced-flows","permalink":"/astonish/docs/tutorials/advanced-flows","draft":false,"unlisted":false,"editUrl":"https://github.com/schardosin/astonish/tree/main/docs/docs/tutorials/advanced-flows.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Using Tools","permalink":"/astonish/docs/tutorials/using-tools"},"next":{"title":"Agent Runner","permalink":"/astonish/docs/api/core/agent-runner"}}');var s=t(4848),r=t(8453);const i={sidebar_position:3},a="Advanced Flows",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Creating Loops",id:"creating-loops",level:2},{value:"Basic Loop with Counter",id:"basic-loop-with-counter",level:3},{value:"Using the <code>limit</code> and <code>limit_counter_field</code> Properties",id:"using-the-limit-and-limit_counter_field-properties",level:3},{value:"Processing Lists",id:"processing-lists",level:3},{value:"Conditional Branching",id:"conditional-branching",level:2},{value:"Simple Branching",id:"simple-branching",level:3},{value:"Complex Decision Trees",id:"complex-decision-trees",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Basic Error Handling",id:"basic-error-handling",level:3},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Combining Multiple Techniques",id:"combining-multiple-techniques",level:2},{value:"Conversational Agents",id:"conversational-agents",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"advanced-flows",children:"Advanced Flows"})}),"\n",(0,s.jsx)(n.p,{children:"This tutorial covers advanced techniques for creating complex agentic flows in Astonish, including loops, conditional branching, error handling, and more."}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"Before you begin, make sure you have:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/getting-started/installation",children:"Installed Astonish"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/getting-started/configuration",children:"Configured an AI provider"})}),"\n",(0,s.jsxs)(n.li,{children:["Basic understanding of ",(0,s.jsx)(n.a,{href:"/docs/concepts/agentic-flows",children:"Agentic Flows"})," and ",(0,s.jsx)(n.a,{href:"/docs/concepts/yaml-configuration",children:"YAML Configuration"})]}),"\n",(0,s.jsxs)(n.li,{children:["Experience with ",(0,s.jsx)(n.a,{href:"/docs/tutorials/creating-agents",children:"Creating Agents"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"creating-loops",children:"Creating Loops"}),"\n",(0,s.jsx)(n.p,{children:"Loops allow your agent to repeat a set of nodes multiple times. This is useful for processing lists of items, implementing retry logic, or creating conversational agents."}),"\n",(0,s.jsx)(n.h3,{id:"basic-loop-with-counter",children:"Basic Loop with Counter"}),"\n",(0,s.jsx)(n.p,{children:"The simplest way to create a loop is using a counter variable and conditional edges:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"nodes:\n  - name: initialize_counter\n    type: llm\n    prompt: |\n      Initialize the counter to 0.\n    output_model:\n      counter: int\n\n  - name: process_iteration\n    type: llm\n    prompt: |\n      Processing iteration {counter}.\n    output_model:\n      result: str\n      counter: int\n\n  - name: check_counter\n    type: llm\n    prompt: |\n      Check if counter {counter} has reached the limit of 5.\n      If counter < 5, increment it by 1.\n      If counter >= 5, keep it as is.\n    output_model:\n      counter: int\n      limit_reached: bool\n\nflow:\n  - from: START\n    to: initialize_counter\n  - from: initialize_counter\n    to: process_iteration\n  - from: process_iteration\n    to: check_counter\n  - from: check_counter\n    edges:\n      - to: process_iteration\n        condition: \"lambda x: not x['limit_reached']\"\n      - to: END\n        condition: \"lambda x: x['limit_reached']\"\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"using-the-limit-and-limit_counter_field-properties",children:["Using the ",(0,s.jsx)(n.code,{children:"limit"})," and ",(0,s.jsx)(n.code,{children:"limit_counter_field"})," Properties"]}),"\n",(0,s.jsx)(n.p,{children:"Astonish provides built-in support for limiting the number of times a node can be executed in a loop:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"nodes:\n  - name: process_item\n    type: llm\n    prompt: |\n      Process item {current_index} from the list: {items}\n    output_model:\n      processed_item: str\n      current_index: int\n    limit: 10  # Maximum number of iterations\n    limit_counter_field: loop_counter  # Counter variable\n"})}),"\n",(0,s.jsx)(n.h3,{id:"processing-lists",children:"Processing Lists"}),"\n",(0,s.jsx)(n.p,{children:"A common use case for loops is processing a list of items:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"nodes:\n  - name: get_items\n    type: llm\n    prompt: |\n      Generate a list of 5 items to process.\n    output_model:\n      items: list\n      current_index: int  # Initialize to 0\n\n  - name: process_item\n    type: llm\n    prompt: |\n      Process item at index {current_index} from the list:\n      {items}\n      \n      Current item: {items[current_index]}\n    output_model:\n      processed_item: str\n      processed_items: list\n\n  - name: update_index\n    type: llm\n    prompt: |\n      Current index: {current_index}\n      Total items: {items}\n      \n      Increment the index by 1 and check if we've processed all items.\n    output_model:\n      current_index: int\n      is_complete: bool\n\nflow:\n  - from: START\n    to: get_items\n  - from: get_items\n    to: process_item\n  - from: process_item\n    to: update_index\n  - from: update_index\n    edges:\n      - to: process_item\n        condition: \"lambda x: not x['is_complete']\"\n      - to: END\n        condition: \"lambda x: x['is_complete']\"\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conditional-branching",children:"Conditional Branching"}),"\n",(0,s.jsx)(n.p,{children:"Conditional branching allows your agent to take different paths based on conditions. This is useful for implementing decision trees, handling different user inputs, or adapting to different scenarios."}),"\n",(0,s.jsx)(n.h3,{id:"simple-branching",children:"Simple Branching"}),"\n",(0,s.jsx)(n.p,{children:"Here's a simple example of conditional branching:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"nodes:\n  - name: get_user_preference\n    type: input\n    prompt: |\n      Do you prefer a detailed or concise response?\n    output_model:\n      preference: str\n    options:\n      - \"Detailed\"\n      - \"Concise\"\n\n  - name: generate_detailed_response\n    type: llm\n    system: |\n      You provide detailed, comprehensive responses.\n    prompt: |\n      Generate a detailed response about {topic}.\n    output_model:\n      response: str\n    user_message:\n      - response\n\n  - name: generate_concise_response\n    type: llm\n    system: |\n      You provide concise, to-the-point responses.\n    prompt: |\n      Generate a concise response about {topic}.\n    output_model:\n      response: str\n    user_message:\n      - response\n\nflow:\n  - from: START\n    to: get_user_preference\n  - from: get_user_preference\n    edges:\n      - to: generate_detailed_response\n        condition: \"lambda x: x['preference'] == 'Detailed'\"\n      - to: generate_concise_response\n        condition: \"lambda x: x['preference'] == 'Concise'\"\n  - from: generate_detailed_response\n    to: END\n  - from: generate_concise_response\n    to: END\n"})}),"\n",(0,s.jsx)(n.h3,{id:"complex-decision-trees",children:"Complex Decision Trees"}),"\n",(0,s.jsx)(n.p,{children:"You can create more complex decision trees by chaining conditional branches:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'nodes:\n  - name: get_query_type\n    type: input\n    prompt: |\n      What type of information are you looking for?\n    output_model:\n      query_type: str\n    options:\n      - "Technical"\n      - "Business"\n      - "General"\n\n  - name: get_technical_detail_level\n    type: input\n    prompt: |\n      What level of technical detail do you need?\n    output_model:\n      detail_level: str\n    options:\n      - "Beginner"\n      - "Intermediate"\n      - "Advanced"\n\n  # ... more nodes for different paths ...\n\nflow:\n  - from: START\n    to: get_query_type\n  - from: get_query_type\n    edges:\n      - to: get_technical_detail_level\n        condition: "lambda x: x[\'query_type\'] == \'Technical\'"\n      - to: get_business_sector\n        condition: "lambda x: x[\'query_type\'] == \'Business\'"\n      - to: get_general_topic\n        condition: "lambda x: x[\'query_type\'] == \'General\'"\n  # ... more flow connections for different paths ...\n'})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Robust agents should handle errors gracefully. You can implement error handling using conditional branches and state variables."}),"\n",(0,s.jsx)(n.h3,{id:"basic-error-handling",children:"Basic Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"nodes:\n  - name: try_operation\n    type: llm\n    prompt: |\n      Try to perform the operation on {input_data}.\n      If successful, set success to true and store the result.\n      If it fails, set success to false and provide an error message.\n    output_model:\n      result: str\n      success: bool\n      error_message: str\n\n  - name: handle_success\n    type: llm\n    prompt: |\n      Operation succeeded with result: {result}\n      Process the successful result.\n    output_model:\n      processed_result: str\n    user_message:\n      - processed_result\n\n  - name: handle_error\n    type: llm\n    prompt: |\n      Operation failed with error: {error_message}\n      Provide guidance on how to resolve the issue.\n    output_model:\n      error_guidance: str\n    user_message:\n      - error_guidance\n\nflow:\n  - from: START\n    to: try_operation\n  - from: try_operation\n    edges:\n      - to: handle_success\n        condition: \"lambda x: x['success']\"\n      - to: handle_error\n        condition: \"lambda x: not x['success']\"\n  - from: handle_success\n    to: END\n  - from: handle_error\n    to: END\n"})}),"\n",(0,s.jsx)(n.h3,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,s.jsx)(n.p,{children:"You can implement retry logic for operations that might fail temporarily:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"nodes:\n  - name: initialize_retry\n    type: llm\n    prompt: |\n      Initialize retry counter to 0.\n    output_model:\n      retry_count: int\n      max_retries: int  # Set to 3\n\n  - name: attempt_operation\n    type: llm\n    prompt: |\n      Attempt operation (retry {retry_count} of {max_retries}).\n    output_model:\n      success: bool\n      result: str\n      error: str\n      retry_count: int\n\n  - name: handle_result\n    type: llm\n    prompt: |\n      Check if operation succeeded or if we've reached max retries.\n      Current retry count: {retry_count}\n      Max retries: {max_retries}\n      Success: {success}\n    output_model:\n      should_retry: bool\n      retry_count: int\n      final_result: str\n    user_message:\n      - final_result\n\nflow:\n  - from: START\n    to: initialize_retry\n  - from: initialize_retry\n    to: attempt_operation\n  - from: attempt_operation\n    to: handle_result\n  - from: handle_result\n    edges:\n      - to: attempt_operation\n        condition: \"lambda x: x['should_retry']\"\n      - to: END\n        condition: \"lambda x: not x['should_retry']\"\n"})}),"\n",(0,s.jsx)(n.h2,{id:"combining-multiple-techniques",children:"Combining Multiple Techniques"}),"\n",(0,s.jsx)(n.p,{children:"Real-world agents often combine multiple advanced techniques. Here's an example of an agent that processes a list of items with retry logic and error handling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"description: Advanced agent that processes a list of items with retry logic and error handling\nnodes:\n  - name: get_items\n    type: input\n    prompt: |\n      Enter a list of items to process (comma-separated):\n    output_model:\n      items_text: str\n\n  - name: parse_items\n    type: llm\n    prompt: |\n      Parse the following comma-separated list into an array:\n      {items_text}\n      \n      Initialize current_index to 0.\n    output_model:\n      items: list\n      current_index: int\n      total_items: int\n\n  - name: process_item\n    type: llm\n    prompt: |\n      Process item {current_index + 1} of {total_items}:\n      Current item: {items[current_index]}\n      \n      Initialize retry_count to 0.\n      Max retries: 3\n    output_model:\n      retry_count: int\n      max_retries: int\n      current_item: str\n      processed_results: list\n\n  - name: attempt_processing\n    type: llm\n    prompt: |\n      Attempt to process item: {current_item}\n      Retry {retry_count} of {max_retries}\n    output_model:\n      success: bool\n      result: str\n      error: str\n      retry_count: int\n\n  - name: handle_attempt_result\n    type: llm\n    prompt: |\n      Check result of processing attempt:\n      Success: {success}\n      Result: {result}\n      Error: {error}\n      Retry count: {retry_count}\n      Max retries: {max_retries}\n      \n      Determine if we should retry or move on.\n    output_model:\n      should_retry: bool\n      retry_count: int\n      processed_results: list\n      current_item_complete: bool\n\n  - name: update_index\n    type: llm\n    prompt: |\n      Current index: {current_index}\n      Total items: {total_items}\n      \n      Increment the index and check if we've processed all items.\n    output_model:\n      current_index: int\n      all_items_processed: bool\n\n  - name: summarize_results\n    type: llm\n    prompt: |\n      Summarize the results of processing all items:\n      {processed_results}\n    output_model:\n      summary: str\n    user_message:\n      - summary\n\nflow:\n  - from: START\n    to: get_items\n  - from: get_items\n    to: parse_items\n  - from: parse_items\n    to: process_item\n  - from: process_item\n    to: attempt_processing\n  - from: attempt_processing\n    to: handle_attempt_result\n  - from: handle_attempt_result\n    edges:\n      - to: attempt_processing\n        condition: \"lambda x: x['should_retry']\"\n      - to: update_index\n        condition: \"lambda x: x['current_item_complete']\"\n  - from: update_index\n    edges:\n      - to: process_item\n        condition: \"lambda x: not x['all_items_processed']\"\n      - to: summarize_results\n        condition: \"lambda x: x['all_items_processed']\"\n  - from: summarize_results\n    to: END\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conversational-agents",children:"Conversational Agents"}),"\n",(0,s.jsx)(n.p,{children:"You can create conversational agents that maintain a dialogue with the user:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"description: Conversational agent that maintains a dialogue with the user\nnodes:\n  - name: initialize_conversation\n    type: llm\n    prompt: |\n      Initialize a conversation with the user.\n      Set conversation_history to an empty list.\n      Generate a greeting message.\n    output_model:\n      conversation_history: list\n      greeting: str\n    user_message:\n      - greeting\n\n  - name: get_user_input\n    type: input\n    prompt: |\n      {greeting}\n    output_model:\n      user_input: str\n\n  - name: process_user_input\n    type: llm\n    system: |\n      You are a conversational assistant that maintains context throughout a conversation.\n    prompt: |\n      Process the user's input and generate a response.\n      \n      Conversation history:\n      {conversation_history}\n      \n      User input:\n      {user_input}\n      \n      Update the conversation history to include this exchange.\n    output_model:\n      response: str\n      conversation_history: list\n      should_continue: bool\n    user_message:\n      - response\n\n  - name: check_continuation\n    type: input\n    prompt: |\n      Would you like to continue the conversation? (yes/no)\n    output_model:\n      continue_conversation: str\n    options:\n      - \"yes\"\n      - \"no\"\n\nflow:\n  - from: START\n    to: initialize_conversation\n  - from: initialize_conversation\n    to: get_user_input\n  - from: get_user_input\n    to: process_user_input\n  - from: process_user_input\n    to: check_continuation\n  - from: check_continuation\n    edges:\n      - to: get_user_input\n        condition: \"lambda x: x['continue_conversation'] == 'yes'\"\n      - to: END\n        condition: \"lambda x: x['continue_conversation'] == 'no'\"\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan your flow carefully"}),": Before implementing complex flows, sketch out the nodes and connections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use descriptive names"}),": Give nodes and variables clear, descriptive names"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep state manageable"}),": Don't overload the state with too many variables"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test incrementally"}),": Build and test your flow in small increments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle edge cases"}),": Consider what might go wrong and add appropriate error handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use comments"}),": Add comments in your YAML file to explain complex logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visualize the flow"}),": Use ",(0,s.jsx)(n.code,{children:"astonish agents flow <agent>"})," to visualize and verify your flow"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you've learned about advanced flows in Astonish, you can:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Explore the ",(0,s.jsx)(n.a,{href:"/docs/api/core/agent-runner",children:"API Reference"})," for more details on Astonish's internals"]}),"\n",(0,s.jsxs)(n.li,{children:["Check out the ",(0,s.jsx)(n.a,{href:"/docs/api/tools/mcp-tools",children:"MCP Tools"})," documentation for extending your agents' capabilities"]}),"\n",(0,s.jsx)(n.li,{children:"Study the sample agents in the Astonish repository for more examples and inspiration"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(6540);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);